import { defu } from 'defu'
import { join, relative, resolve as resolvePath } from 'pathe'

import { addImports, addPlugin, addRouteMiddleware, addServerHandler, addTemplate, createResolver, defineNuxtModule, findPath, useLogger } from '@nuxt/kit'
import type { Nuxt } from '@nuxt/schema'
import { name, version } from '../package.json'

export interface ModuleOptions {
  /**
   * @default `/sign-in`
   */
  signIn?: string

  /**
   * @default true
   */
  global: boolean

  /**
   * Whether to refresh the session every `X` milliseconds. Set this to `false` to turn it off. The session will only be refreshed if a session already exists.
   *
   * Setting this to `false` will turn off session refresh.
   * Setting this to a number `X` will refresh the session every `X` milliseconds.
   *
   * @example 1000
   * @default false
   *
   */
  refreshPeriodically: number | false

  /**
   * Whether to refresh the session every time the browser window is refocused.
   *
   * @example false
   * @default false
   */
  refreshOnWindowFocus: boolean
}

export type PublicModuleOptions = Pick<ModuleOptions, 'signIn' | 'global' | 'refreshPeriodically' | 'refreshOnWindowFocus'>

export default defineNuxtModule<ModuleOptions>({
  meta: {
    name,
    version,
    configKey: 'auth',
  },
  async setup(userOptions, nuxt) {
    const logger = useLogger(name)

    logger.info(`\`${name}\` setup...`)

    const options = defu<ModuleOptions, [ModuleOptions]>(userOptions, {
      global: true,
      refreshPeriodically: false,
      refreshOnWindowFocus: false,
    })

    // Set the module options
    nuxt.options.runtimeConfig.auth = options as any

    // Be explicit on what we set publicly
    nuxt.options.runtimeConfig.public.auth = {
      signIn: options.signIn,
      // global: options.global,
      refreshPeriodically: options.refreshPeriodically as any,
      refreshOnWindowFocus: options.refreshOnWindowFocus,
    }

    // check if the signIn page exists
    if (options.signIn) {
      if (!await findPagePath(nuxt, options.signIn)) {
        logger.warn(`\`${name}\` signIn page \`${join('pages', `${options.signIn}.vue`)}\` is missing, the application may never load...`)
      }
    }

    const runtimeConfig = nuxt.options.runtimeConfig
    runtimeConfig.session = defu(runtimeConfig.session, {
      name: '__session',
      password: '',
      cookie: {
        sameSite: 'lax',
      },
    })
    runtimeConfig.oauth = defu(runtimeConfig.oauth, {})
    runtimeConfig.oauth.github = defu(runtimeConfig.oauth.github, {
      clientId: '',
      clientSecret: '',
    })
    runtimeConfig.oauth.google = defu(runtimeConfig.oauth.google, {
      clientId: '',
      clientSecret: '',
    })

    const resolver = createResolver(import.meta.url)

    // Resolve the server-side runtime
    const serverRuntime = resolver.resolve('./runtime/server')

    // Add the auth handler
    addServerHandler({
      route: '/api/auth/**',
      handler: resolver.resolve('./runtime/server/api/auth/[...]'),
    })

    // Add the route middleware
    addRouteMiddleware({
      global: options.global ?? true,
      name: 'auth',
      path: resolver.resolve('./runtime/middleware/auth'),
    })

    // Add the client-side plugins
    addPlugin({
      mode: 'client',
      src: resolver.resolve('./runtime/plugin.client'),
    })

    // Add the server-side plugins
    addPlugin({
      mode: 'server',
      src: resolver.resolve('./runtime/plugin.server'),
    })

    // Add all the composables, be explicit on what we add
    addImports([
      {
        name: 'useAuth',
        from: resolver.resolve('./runtime/composables/useAuth'),
      },
    ])

    // 5. Create virtual imports for server-side
    nuxt.hook('nitro:config', (nitroConfig) => {
      nitroConfig.alias = nitroConfig.alias || {}

      // Inline module runtime in Nitro bundle
      nitroConfig.externals = defu(typeof nitroConfig.externals === 'object' ? nitroConfig.externals : {}, {
        inline: [resolver.resolve('./runtime')],
      })

      nitroConfig.alias['#auth'] = resolver.resolve('./runtime/server')
    })

    addTemplate({
      filename: 'types/auth.d.ts',
      getContents: () => {
        const authPlugin = resolver.resolve(nuxt.options.serverDir, './plugins/auth')

        return `// Generated by ${name} ${version}

declare module '#auth' {
  export const authPlugin: typeof import('${serverRuntime}').authPlugin
  export const getSession: typeof import('${serverRuntime}').getSession

  /**
   * The Auth type.
   */
  export type Auth = typeof import('${authPlugin}').default

  export type AuthUser = import('${serverRuntime}').inferUser<Auth>

  export interface Session {
    expire: string,
    user: AuthUser
  }
}
`
      },
    })

    nuxt.hook('prepare:types', (options) => {
      options.references.push({ path: resolver.resolve(nuxt.options.buildDir, 'types/auth.d.ts') })
    })

    logger.success(`\`${name}\` setup done`)
  },
})

/**
 * Find the fully qualified file path of a page, return `null` if it doesn't exist.
 * It usually terminates with `.vue`.
 *
 * @param nuxt The Nuxt instance
 * @param path The page router path, without the file extension
 */
function findPagePath(nuxt: Nuxt, path: string) {
  const pagesDir = resolvePath(resolvePath(nuxt.options.srcDir), nuxt.options.dir.pages)

  const singInPage = join(pagesDir, path)

  return findPath(relative(pagesDir, singInPage), { cwd: pagesDir })
}
